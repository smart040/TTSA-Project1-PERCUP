{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b9316501-8fe0-4eaf-9574-537c47903ef1",
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from ripser import ripser\n",
    "from persim import plot_diagrams\n",
    "from sklearn.cluster import KMeans\n",
    "import tadasets\n",
    "from itertools import combinations\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "774abd83-9462-4ee0-ac25-002e00535e9b",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Functions used\n",
    "\n",
    "def kmeans_downsampling(data, num_points): #Sampling\n",
    "    kmeans = KMeans(n_clusters=num_points, random_state=0).fit(data)\n",
    "    centroids = kmeans.cluster_centers_\n",
    "    return centroids\n",
    "num_points = 100\n",
    "\n",
    "def cupProduct(phi, psi, triangleList): #Compute Cup Product\n",
    "    cupProduct = []\n",
    "    for i in range(len(triangleList)):\n",
    "        phiVal = 0\n",
    "        psiVal = 0\n",
    "        for j in range(len(phi)):\n",
    "            if phi[j][0] == triangleList[i][0] and phi[j][1] == triangleList[i][1]:\n",
    "                phiVal = phi[j][2]\n",
    "                break;\n",
    "        for k in range(len(psi)):\n",
    "            if psi[k][0] == triangleList[i][1] and psi[k][1] == triangleList[i][2]:\n",
    "                psiVal = psi[k][2]\n",
    "                break;\n",
    "        cupProduct.append(phiVal * psiVal)\n",
    "    cupProduct = np.array(cupProduct).T\n",
    "    return cupProduct\n",
    "\n",
    "def reductionAlgorithm(R):\n",
    "    numRows = len(R[0])\n",
    "    V = np.eye(numRows)\n",
    "    pivotRows, pivotEntries = [[] for i in range (numRows)], [[] for i in range (numRows)]\n",
    "\n",
    "    for i in range(numRows):\n",
    "        h = 0\n",
    "        while (h == 0):\n",
    "            pivotRow = np.inf\n",
    "            for j in range(numRows - 1, -1, -1):\n",
    "                if R[j][i] != 0:\n",
    "                    pivotRow = j\n",
    "                    break;\n",
    "            if pivotRow == np.inf:\n",
    "                pivotEntries[i] = 0\n",
    "            else:\n",
    "                pivotEntries[i] = R[pivotRow][i]\n",
    "            pivotRows[i] = pivotRow\n",
    "            if pivotRow == np.inf or all(pivotRows[k] != pivotRows[i] for k in range(i)):\n",
    "                h = 1\n",
    "                break;\n",
    "            for k in range(i):\n",
    "                if pivotRows[k] == pivotRows[i]:\n",
    "                    c = pivotEntries[i] // pivotEntries[k]\n",
    "                    for l in range(numRows):\n",
    "                        R[l][i] -= c * R[l][k]\n",
    "                        V[l][i] -= c * V[l][k]            \n",
    "    return R\n",
    "\n",
    "def checkSolution(A, b):\n",
    "    # Calculate the rank of the augmented matrix [A | b]\n",
    "    augmented_matrix = np.column_stack((A, b))\n",
    "    rank_A = np.linalg.matrix_rank(A)\n",
    "    rank_augmented = np.linalg.matrix_rank(augmented_matrix)\n",
    "    num_columns = A.shape[1]\n",
    "    num_rows = A.shape[0]\n",
    "    if rank_A == rank_augmented:\n",
    "        if rank_A == num_columns:\n",
    "            return 1\n",
    "        elif rank_A < num_columns:\n",
    "            return 1\n",
    "    else:\n",
    "        if rank_A < rank_augmented:\n",
    "            return 0\n",
    "    return \"Unable to determine the solution status.\"\n",
    "\n",
    "def rowDetect(A, b):\n",
    "    iMax = len(A) + 1\n",
    "    iMin = 1\n",
    "    i = len(A) // 2\n",
    "    running = True\n",
    "    while(running):\n",
    "        sol = checkSolution(A[-i:], b[-i:])\n",
    "        if sol == 0:\n",
    "            if checkSolution(A[-(i - 1):], b[-(i - 1):]) == 1:\n",
    "                row = len(A) - i\n",
    "                running = False\n",
    "                break;\n",
    "            else:\n",
    "                if i < iMax:\n",
    "                    iMax = i\n",
    "                    i = (iMax + iMin) // 2\n",
    "        if sol == 1:\n",
    "            if i > iMin:\n",
    "                iMin = i\n",
    "                i = (iMax + iMin) // 2\n",
    "    return row+1\n",
    "\n",
    "def rowTriangle(r):\n",
    "    value=len(triangles)-1-r\n",
    "    return triangles[value]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "e59918ad-b62b-4826-8a9a-5f62b58c6a55",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Generate a shape\n",
    "\n",
    "np.random.seed(2) #This for a torus\n",
    "n_data = 25000\n",
    "R = 5\n",
    "r = 2\n",
    "data = np.zeros((3, n_data))\n",
    "s = np.random.rand(n_data)*2*np.pi\n",
    "t = np.random.rand(n_data)*2*np.pi\n",
    "data[0] = (R + r*np.cos(s))*np.cos(t)\n",
    "data[1] = (R + r*np.cos(s))*np.sin(t)\n",
    "data[2] = r*np.sin(s)\n",
    "data += 0.1*np.random.randn(*data.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "93df142b-8eca-43ef-95ba-27a391a3501f",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/austinmbaye/anaconda3/lib/python3.10/site-packages/sklearn/cluster/_kmeans.py:870: FutureWarning: The default value of `n_init` will change from 10 to 'auto' in 1.4. Set the value of `n_init` explicitly to suppress the warning\n",
      "  warnings.warn(\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Time Elapsed = 70.39373803138733\n"
     ]
    }
   ],
   "source": [
    "start_time=time.time()\n",
    "\n",
    "#Part 1: Get the Cup Product\n",
    "x = kmeans_downsampling(data.T, 100)\n",
    "result = ripser(x, coeff=2, do_cocycles=True)\n",
    "diagrams = result['dgms']\n",
    "cocycles = result['cocycles'] #all of the cocycles\n",
    "D = result['dperm2all'] #distance matrix between the ith and jth points in the data\n",
    "dgm1 = diagrams[1]\n",
    "#Representative cocycle phi\n",
    "idx1 = np.argmax(dgm1[:, 1] - dgm1[:, 0])\n",
    "cocycle1 = cocycles[1][idx1]\n",
    "#Representative cocycle psi\n",
    "sorted_indices = np.argsort(dgm1[:, 1] - dgm1[:, 0])\n",
    "idx2 = sorted_indices[-2]\n",
    "cocycle2 = cocycles[1][idx2]\n",
    "\n",
    "#Restrict cocycle1\n",
    "New_cocycle1=[]\n",
    "edges=[]\n",
    "for i in range(len(cocycle1)):\n",
    "        for j in range(len(cocycle2)):\n",
    "            if np.array_equal(cocycle1[i:i-1, :2], cocycle1[i:i+1, :2], cocycle2[j:j+1, :2]):  \n",
    "                New_cocycle1.append(cocycle2[j:j+1])\n",
    "        New_cocycle1.append(cocycle2[i:i+1])        \n",
    "rcocycle1=np.vstack(New_cocycle1)\n",
    "for i in range(len(cocycle1)):\n",
    "        for j in range(len(cocycle2)):\n",
    "            if np.array_equal(cocycle1[i-1:i, :2], cocycle2[j:j+1, :2]):\n",
    "                edges.append(cocycle2[j:j+1])        \n",
    "edges=np.vstack(edges)\n",
    "for i in range(len(rcocycle1)):\n",
    "    found_match = False\n",
    "    for j in range(len(edges)):\n",
    "        if np.array_equal(rcocycle1[i, :2], edges[j, :2]):\n",
    "            found_match = True\n",
    "            break\n",
    "    if not found_match:\n",
    "        rcocycle1[i, -1] = 0\n",
    "        \n",
    "# Finding the representative cocycles for triangles\n",
    "representative_cocycles = []\n",
    "for i in range(len(dgm1)):\n",
    "    birth, death = dgm1[i]\n",
    "    if birth != death:  # ignore points on the diagonal\n",
    "        cocycle = cocycles[1][i]\n",
    "        representative_cocycles.append(cocycle)\n",
    "triangles = []\n",
    "for cocycle in representative_cocycles:\n",
    "    edge_indices = cocycle[:, :2].astype(int)\n",
    "    triangle_vertices = set()\n",
    "    for i, j in edge_indices:\n",
    "        triangle_vertices.add(i)\n",
    "        triangle_vertices.add(j)\n",
    "    triangle_combinations = combinations(triangle_vertices, 3)\n",
    "    for combination in triangle_combinations:\n",
    "        triangles.append(list(combination))\n",
    "t=np.vstack(triangles)\n",
    "\n",
    "cup=cupProduct(rcocycle1,cocycle2, t)#Compute the cup Product\n",
    "cup=np.vstack(cup)\n",
    "\n",
    "#Part 2: Get the Coboundary Matrix\n",
    "edges = []\n",
    "vertices=[]\n",
    "representative_cocycles = []\n",
    "for i in range(len(dgm1)):\n",
    "    birth, death = dgm1[i]\n",
    "    if birth != death:  \n",
    "        cocycle = cocycles[1][i]\n",
    "        representative_cocycles.append(cocycle)\n",
    "for cocycle in representative_cocycles: # Extracting every edge as an array of vertices\n",
    "    edge_indices = cocycle[:, :2].astype(int)\n",
    "    for i, j in edge_indices:\n",
    "        edge = [i, j]\n",
    "        edges.append(edge)\n",
    "for cocycle in representative_cocycles: #Extracting every vertex\n",
    "    vertex_indices = cocycle[:, :1].astype(int)\n",
    "    for i in vertex_indices:\n",
    "        vertices.append(i[0])\n",
    "vertices = list(set(vertices)) # Remove duplicate vertices by converting the list to a set and then back to a list\n",
    "\n",
    "ne = len(edges)\n",
    "nt = len(triangles)\n",
    "nv = len(vertices)\n",
    "num_rows= ne+nt+nv\n",
    "num_cols=ne+nt+nv\n",
    "boundary_matrix=np.zeros((num_rows, num_cols), dtype=int)\n",
    "for i,edge in enumerate(edges):\n",
    "    a,b=edge #a and b are the two verticies that make up the edge\n",
    "    for j,vertex in enumerate(vertices):\n",
    "        c=vertex # c is a vertex\n",
    "        if b == c:\n",
    "            boundary_matrix[nv+i,j]=1\n",
    "        if a == c:\n",
    "            boundary_matrix[nv+i,j]=-1\n",
    "for i, triangle in enumerate(triangles):\n",
    "    e,f,g=triangle #e,f,g are verticies in the triangle\n",
    "    for j,edge in enumerate(edges):\n",
    "        h,k=edge \n",
    "        if (h,k) == (e,f):\n",
    "            boundary_matrix[(ne+nv)+i,nv+j]=1\n",
    "        if (h,k) == (f,g):\n",
    "            boundary_matrix[(ne+nv)+i,nv+j]=1\n",
    "        if (h,k) == (e,g):\n",
    "            boundary_matrix[(ne+nv)+i,nv+j]=-1\n",
    "boundary_matrix=boundary_matrix.T\n",
    "#Convert Boundary Matrix into Coboundary\n",
    "restricted_matrix = boundary_matrix[nv:nv + ne, nv + ne:len(boundary_matrix)]\n",
    "coboundary_matrix = np.flip(restricted_matrix).T\n",
    "\n",
    "#Part 3: Solve for x\n",
    "reduce=reductionAlgorithm(coboundary_matrix) #Reduce Coboundary Matrix\n",
    "detect=rowDetect(reduce, cup) #detect row when matrix no longer has a solution\n",
    "tri=rowTriangle(detect) #Obtain associated triangle with the detected row\n",
    "sorted_indices = np.argsort(dgm1[:, 1] - dgm1[:, 0])\n",
    "idx = sorted_indices[-2]\n",
    "h = max(dgm1[idx, 0], dgm1[idx, 0])\n",
    "while h < min(dgm1[idx, 1], dgm1[idx, 1]):\n",
    "    newRun = ripser(x, coeff=2, thresh = h, do_cocycles = True)\n",
    "    newDiagrams = newRun['dgms']\n",
    "    newCocycles = newRun['cocycles']\n",
    "    D = newRun['dperm2all']\n",
    "    dgmNew = newDiagrams[1]\n",
    "    new_representative_cocycles = []\n",
    "    for i in range(len(dgmNew)):\n",
    "        birth, death = dgmNew[i]\n",
    "        if birth != death:  # ignore points on the diagonal\n",
    "            newCocycle = newCocycles[1][i]\n",
    "            new_representative_cocycles.append(newCocycle)\n",
    "    newTriangles = []\n",
    "    for newCocycle in new_representative_cocycles:\n",
    "        edge_indices = newCocycle[:, :2].astype(int)\n",
    "        new_triangle_vertices = set()\n",
    "        for i, j in edge_indices:\n",
    "            new_triangle_vertices.add(i)\n",
    "            new_triangle_vertices.add(j)\n",
    "        new_triangle_combinations = combinations(new_triangle_vertices, 3)\n",
    "        for combination in new_triangle_combinations:\n",
    "            newTriangles.append(list(combination))\n",
    "    t=np.vstack(newTriangles)\n",
    "    for k in range(len(t)):\n",
    "        if t[k][0] == tri[0] and t[k][1] == tri[1] and t[k][2] == tri[2]:\n",
    "            death=h #Gives the Cohomological death \n",
    "            h = 1000000\n",
    "            break;\n",
    "    h += 0.1\n",
    "\n",
    "#Part 4: Plot the persistence diagram with the new point\n",
    "birth=dgm1[idx2,1] #death of psi but birth of H2 point \n",
    "plot_diagrams(diagrams, show = False)\n",
    "plt.scatter(dgm1[0], dgm1[1], 20)\n",
    "plt.scatter(death,birth, color='g')\n",
    "plt.title(\"Peristence Diagram\")\n",
    "plt.show()\n",
    "end_time=(time.time()-start_time)\n",
    "print(\"Time Elapsed =\",end_time)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
